---
published : true 
title : 선형변환  
layout : single 
toc : true 
katex : True 
---
# 선형변환
선형변환에 의해 벡터를 변환합니다. 인공지능에서는 뉴럴 네트워크로 정보를 전파시키는데 선형변환을 사용합니다.

## 벡터 그리기
다음의 세로 벡터를 화살표로 그립니다.

$$
\vec{a} = \begin{cases}2 \\3 \end{cases} \\
$$



화살표를 그리려면 matplotlib.pyplot의 **quiver()** 함수를 사용합니다. **quiver()** 함수는 아래와 같이 작성합니다.



quiver(시작점의 x좌표, 끝점의 y좌표, 화살표의 x성분, 화살표의y 성분,angles=화살표의 삭도 결정 방법,scale_units=스케일 단위,scale=스케일,color=화살표색)

화살표의 x성분과 y 성분으로 벡터를 표현합니다. 아래코드는 angle,scale_units,scale은 사용하지않습니다.



```python
import numpy as np
import matplotlib.pyplot as plt

np.finfo(np.dtype("float32"))
np.finfo(np.dtype("float64"))

# 화살표를 그리는 함수
def arrow(start,size,color):
    plt.quiver(start[0],start[1],size[0],size[1],angles="xy",scale_units="xy",scale=1,color=color)
    
#화살표의 시작점
s = np.array([0,0]) # 원점

# 벡터
a = np.array([2,3]) # 세로 벡터를 나타낸다.


arrow(s,a,color="black")

#그래프 표시
plt.xlim([-3,3]) # x의 표시 범위
plt.ylim([-3,3]) # y의 표시 범위
plt.xlabel("x",size=14)
plt.ylabel("y",size=14)
plt.grid()
plt.gca().set_aspect("equal") # 가로세로비를 같게
plt.show()
```


    
![png](../assets/images/%EC%84%A0%ED%98%95%EB%B3%80%ED%99%98_4_0.png)
    


원점을 시작점으로 한 화살표로 벡터를 그릴 수 있었습니다.

## 선형변환

다음의 행렬 A를 살펴봅시다.

$$ A = 
\begin{pmatrix}
2 & -1 \\
2 & -2 \\
\end{pmatrix}
$$

다음과 같이해서 이 행렬 A를 세로 벡터 $$\vec{a} $$에 곱함으로써 벡터를 변환할 수 있습니다.

$$
\vec{b} = A\vec{a} = 
\begin{pmatrix}
2 & -1 \\
2 & -2 \\
\end{pmatrix}\begin{pmatrix}
2 \\
3 \\
\end{pmatrix} 
= \begin{pmatrix}
1 \\
-2 \\
\end{pmatrix}
$$

위와 같이 행렬 A에 의해 벡터 $$\vec{a}$$ 는 벡터 $$\vec{b}$$로 변환됐습니다.
이처럼 벡터에서 벡터로의 변환을 선형변환이라고 합니다.
변환 전의 벡터 $$\vec{a}$$, 변환 후의 벡터 $$\vec{b}$$를 화살표로 그리면 아래와 같습니다.



```python
import numpy as np
import matplotlib.pyplot as plt

a = np.array([2,3]) # 변환 전의 벡터

A = np.array([[2,-1],[2,-2]])

b = np.dot(A,a) # 선형변환

print("변환 전의 벡터(a):",a)
print("변환 후의 벡터(b):",b)

# 화살표를 그리는 함수
def arrow(start,size,color):
    plt.quiver(start[0],start[1],size[0],size[1],angles="xy",scale_units="xy",scale=1,color=color)
    

s = np.array([0,0]) # 원점

arrow(s,a,color="black")
arrow(s,b,color="blue")

#그래프 표시
plt.xlim([-3,3]) # x의 표시 범위
plt.ylim([-3,3]) # y의 표시 범위
plt.xlabel("x",size=14)
plt.ylabel("y",size=14)
plt.grid()
plt.gca().set_aspect("equal") # 가로세로비를 같게
plt.show()

```

    변환 전의 벡터(a): [2 3]
    변환 후의 벡터(b): [ 1 -2]



    
![png](../assets/images/%EC%84%A0%ED%98%95%EB%B3%80%ED%99%98_10_1.png)
    


행렬 A에 의해 검정색 화살표로 표시되는 벡터 $$\vec{a}$$가 파란색 화살표로 표시되는 벡터$$\vec{b}$$로 변환됐습니다.

## 표준기저

다음의 벡터 $$\vec{e_x}$$와 $$\vec{e_y}$$는 **표준기저**라고 합니다.

$$
\vec{e_x} = \begin{pmatrix}
1 \\
0 \\
\end{pmatrix} \\
\vec{e_y} = \begin{pmatrix}
0 \\
1 \\
\end{pmatrix}
$$


이때, 벡터$$\vec{a}$$는 다음과 같이 나타낼 수 있습니다.

$$
\vec{a} = \begin{pmatrix}
2 \\
3 \\
\end{pmatrix}= 
2\begin{pmatrix}
1 \\
0 \\
\end{pmatrix} + 
3\begin{pmatrix}
0 \\
1 \\
\end{pmatrix} = 2\vec{e_x} + 3\vec{e_y}
$$

이상과 같이 벡터는 표준기저와 상수의 곱의 합으로 표현할 수 있습니다.
아래는 표준기저를 그립니다.


```python
import numpy as np
import matplotlib.pyplot as plt

a = np.array([2,3])
e_x = np.array([1,0]) # 표준기저
e_y = np.array([0,1]) # 표준기저

print("a:",a)
print("e_x:",e_x)
print("e_y",e_y)

# 화살표를 그리는 함수
def arrow(start,size,color):
    plt.quiver(start[0],start[1],size[0],size[1],angles="xy",scale_units="xy",scale=1,color=color)
    

s = np.array([0,0]) # 원점

arrow(s,a,color="blue")
arrow(s,e_x,color="black")
arrow(s,e_y,color="black")

#그래프 표시
plt.xlim([-3,3]) # x의 표시 범위
plt.ylim([-3,3]) # y의 표시 범위
plt.xlabel("x",size=14)
plt.ylabel("y",size=14)
plt.grid()
plt.gca().set_aspect("equal") # 가로세로비를 같게
plt.show()

```

    a: [2 3]
    e_x: [1 0]
    e_y [0 1]



    
![png](../assets/images/%EC%84%A0%ED%98%95%EB%B3%80%ED%99%98_15_1.png)
    


파란색 화살표의 벡터는 검정색 화살표의 표준기저에 상수를 곱하고 더함으로써 나타납니다.

표준기저를 이용하여 벡터의 일반적인 표현을 합니다.
m개의 요소를 가진 벡터 $$\vec{a}$$ 는 표준기저를 이용해 다음과 같이 나타냅니다.

$$
\vec{a} = \sum_{j=1}^m r_j{\vec{e_j}}
$$

$$r_j$$가 상수로 $$\vec{e_j}$$가 각 요소에 대응하는 표준기저입니다.

이 벡터에 다음의 n * m 행렬 P를 사용해서 선형변환을 실시합니다.

$$
A = \begin{pmatrix}
a_{11} & a_{12} & \cdots & a_{1n}\\
a_{21} & a_{22} & \cdots & a_{2n}\\
\vdots & \vdots & \ddots & \vdots \\
a_{m1} & a_{m2} & \cdots & a_{mn}
\end{pmatrix}
$$

$$
\vec{b} = A\vec{a}
$$

이 결과 얻어진 $$\vec{b}$$는 표준기저를 사용해 다음과 같이 나타낼 수 있습니다.

$$
\vec{b} = \sum_{k=1}^n s_k\vec{e_k}
$$

$$
{s_k}=\sum_{j=1}^m {r_j}{a_{kj}}
$$

$${s_k}$$는 $$\vec{b}$$의 각 표준기저에 곱하는 상수입니다. 

이처럼 $$\vec{b}$$의 각 요소는 곱의 총합의 형태로 나타냅니다. 이 선형변환의 성질을 잉요하여 뉴럴 네트워크에서는 의사적인 신경 세포에 대한 여러 개의 입력에 가중치를 곱한 총합을 계산합니다.

또한, n=m 이면 행렬 A는 정방행렬이 되는데 A가 정방행렬이 아니면 선형변환에 의해 벡터의 요소 수가 변하게 됩니다.
예를 들어 다음 예에서는 선형변환에 의해 벡터의 요소 수가 2에서 3으로 변환합니다.

$$
\begin{pmatrix}
2 & -1 \\
2 & -2 \\
-1 & 2
\end{pmatrix}\begin{pmatrix}
2\\
3
\end{pmatrix}=\begin{pmatrix}
1\\
-2\\
4
\end{pmatrix}
$$

-2\\
4
\end{pmatrix}
$$
