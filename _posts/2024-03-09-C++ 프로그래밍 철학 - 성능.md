---
published : true 
title : C++ 프로그래밍 철학 - 성능  
layout : single 
toc : true 
katex : True 
---
# 성능

c++를 사용하는 가장 큰 이유중 하나는 성능입니다.

루프문 사용중 성능에 관해 생각해 볼 코드를 보여드립니다.

```cpp
#include <iostream>
#include <vector>
#include <chrono>
using namespace std;
using namespace std::chrono;

void goodExample(vector<int>& numbers) {
    int size = numbers.size();

    auto start = high_resolution_clock::now();

    for (int i = 0; i < size; ++i) {
    }

    auto stop = high_resolution_clock::now();
    auto duration = duration_cast<milliseconds>(stop - start);
    cout << "Good example execution time: " << duration.count() << " milliseconds" << endl;
}

void badExample(vector<int>& numbers) {
    auto start = high_resolution_clock::now();

    for (int num : numbers) {
    }

    auto stop = high_resolution_clock::now();
    auto duration = duration_cast<milliseconds>(stop - start);
    cout << "Bad example execution time: " << duration.count() << " milliseconds" << endl;
}

int main() {
    vector<int> numbers;
    for (int i = 0; i < 100000000; ++i) {
        numbers.push_back(i);
    }
    
    goodExample(numbers);
    badExample(numbers);

    return 0;
}
```

```
Good example execution time: 226 milliseconds
Bad example execution time: 794 milliseconds
```


goodExample 함수는 벡터의 크기를 먼저 확인하고, 

그 다음에 인덱스를 사용하여 각 요소에 접근합니다. 

이 방법은 벡터의 인덱스 접근을 최적화하고 있으며, 

순차적으로 메모리에 접근합니다.


badExample 함수는 범위 기반의 for 루프를 사용하여 각 요소에 접근합니다. 

이 방법은 벡터를 루프 돌면서 각 요소를 복사한 후에 사용하므로 불필요한 복사와 메모리 액세스가 발생합니다.

따라서, goodExample 함수는 좋은 예제로 간주될 수 있습니다. 

그러나 badExample 함수는 벡터의 요소를 복사하고 있는 문제가 있으므로 실행 속도가 느립니다.

실행 속도의 차이는 주로 데이터 액세스 패턴에서 비롯됩니다. 

goodExample 함수는 인덱스를 사용하여 각 요소에 접근하기 때문에 메모리 캐시의 지역성을 보장하며, 

효율적인 메모리 액세스 패턴을 유지합니다. 

반면에, badExample 함수는 범위 기반의 for 루프를 사용하여 각 요소를 복사한 후 사용하기 때문에 메모리 캐시의 성능을 해치고, 

비효율적인 메모리 액세스 패턴을 갖습니다.

결론적으로, 좋은 프로그래밍 관행은 가능한한 메모리 액세스 패턴을 최적화하여 데이터의 지역성을 활용하고, 비효율적인 복사를 피하는 것입니다.



